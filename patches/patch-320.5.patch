diff -Nru mDNSResponder-320.5/Clients/dns-sd.c mdns-patched/Clients/dns-sd.c
--- mDNSResponder-320.5/Clients/dns-sd.c	2011-04-06 22:48:43.000000000 +0000
+++ mdns-patched/Clients/dns-sd.c	2011-12-07 15:33:42.980377272 +0000
@@ -170,7 +170,16 @@
 	#include <arpa/inet.h>		// For inet_addr()
 	#include <net/if.h>			// For if_nametoindex()
 	static const char kFilePathSep = '/';
-	#define SA_LEN(addr) ((addr)->sa_len)
+   //#define SA_LEN(addr) (sizeof(*addr))
+
+	static size_t _sa_len(const struct sockaddr *addr)
+		{
+		if (addr->sa_family == AF_INET) return (sizeof(struct sockaddr_in));
+		else if (addr->sa_family == AF_INET6) return (sizeof(struct sockaddr_in6));
+		else return (sizeof(struct sockaddr));
+		}
+
+   #   define SA_LEN(addr) (_sa_len(addr))
 #endif
 
 #if (TEST_NEW_CLIENTSTUB && !defined(__APPLE_API_PRIVATE))
diff -Nru mDNSResponder-320.5/mDNSPosix/Identify.c mdns-patched/mDNSPosix/Identify.c
--- mDNSResponder-320.5/mDNSPosix/Identify.c	2011-03-17 23:25:38.000000000 +0000
+++ mdns-patched/mDNSPosix/Identify.c	2011-12-07 15:33:42.450353997 +0000
@@ -34,8 +34,10 @@
 // We want to use the functionality provided by "mDNS.c",
 // except we'll sneak a peek at the packets before forwarding them to the normal mDNSCoreReceive() routine
 #define mDNSCoreReceive __MDNS__mDNSCoreReceive
+#define UDPSocket_struct __UDPSocket_struct
 #include "mDNS.c"
 #undef mDNSCoreReceive
+#undef UDPSocket_struct
 
 //*************************************************************************************************************
 // Headers
diff -Nru mDNSResponder-320.5/mDNSPosix/NetMonitor.c mdns-patched/mDNSPosix/NetMonitor.c
--- mDNSResponder-320.5/mDNSPosix/NetMonitor.c	2011-04-19 22:45:39.000000000 +0000
+++ mdns-patched/mDNSPosix/NetMonitor.c	2011-12-07 15:33:42.350349607 +0000
@@ -34,8 +34,10 @@
 // We want to use much of the functionality provided by "mDNS.c",
 // except we'll steal the packets that would be sent to normal mDNSCoreReceive() routine
 #define mDNSCoreReceive __NOT__mDNSCoreReceive__NOT__
+#define UDPSocket_struct __UDPSocket_struct
 #include "mDNS.c"
 #undef mDNSCoreReceive
+#undef UDPSocket_struct
 
 //*************************************************************************************************************
 // Headers
diff -Nru mDNSResponder-320.5/mDNSPosix/PosixDaemon.c mdns-patched/mDNSPosix/PosixDaemon.c
--- mDNSResponder-320.5/mDNSPosix/PosixDaemon.c	2010-04-25 22:14:24.000000000 +0000
+++ mdns-patched/mDNSPosix/PosixDaemon.c	2011-12-07 15:33:42.590360143 +0000
@@ -50,6 +50,12 @@
 #include "PlatformCommon.h"
 
 #define CONFIG_FILE "/etc/mdnsd.conf"
+
+// service registration
+#define SERVICES_FILE "/etc/mdnsd-services.conf"
+static mStatus RegisterServicesInFile(const char *filePath);
+static void DeregisterOurServices(void);
+
 static domainname DynDNSZone;                // Default wide-area zone for service registration
 static domainname DynDNSHostname;
 
@@ -87,14 +93,19 @@
 static void Reconfigure(mDNS *m)
 	{
 	mDNSAddr DynDNSIP;
-	const mDNSAddr dummy = { mDNSAddrType_IPv4, { { { 1, 1, 1, 1 } } } };;
-	mDNS_SetPrimaryInterfaceInfo(m, NULL, NULL, NULL);
+   const mDNSAddr dummy = { mDNSAddrType_IPv4, { { { 1, 1, 1, 1 } } } };;
+   mDNSAddr router;
+   mDNS_SetPrimaryInterfaceInfo(m, NULL, NULL, NULL);
 	if (ParseDNSServers(m, uDNS_SERVERS_FILE) < 0)
 		LogMsg("Unable to parse DNS server list. Unicast DNS-SD unavailable");
 	ReadDDNSSettingsFromConfFile(m, CONFIG_FILE, &DynDNSHostname, &DynDNSZone, NULL);
 	mDNSPlatformSourceAddrForDest(&DynDNSIP, &dummy);
 	if (DynDNSHostname.c[0]) mDNS_AddDynDNSHostName(m, &DynDNSHostname, NULL, NULL);
-	if (DynDNSIP.type)       mDNS_SetPrimaryInterfaceInfo(m, &DynDNSIP, NULL, NULL);
+	if (DynDNSIP.type) {
+      int r = mDNS_PlatformGetGateway(NULL, &router, NULL);
+      mDNS_SetPrimaryInterfaceInfo(m, &DynDNSIP, NULL, (mStatus_NoError == r) ? &router : NULL);
+   }
+   
 	mDNS_ConfigChanged(m);
 	}
 
@@ -194,9 +205,14 @@
 			LogMsg("WARNING: mdnsd continuing as root because user \"nobody\" does not exist");
 		}
 
+   if(mStatus_NoError != RegisterServicesInFile(SERVICES_FILE))
+      LogMsg("Failed to register (some) services from %s.", SERVICES_FILE);
+
 	if (mStatus_NoError == err)
 		err = MainLoop(&mDNSStorage);
  
+   DeregisterOurServices();
+ 
 	LogMsg("%s stopping", mDNSResponderVersionString);
 
 	mDNS_Close(&mDNSStorage);
@@ -242,6 +258,325 @@
 	// No-op, for now
 	}
 
+// registering services from config file
+
+#include <assert.h>
+
+typedef struct PosixService PosixService;
+
+struct PosixService {
+    ServiceRecordSet coreServ;
+    PosixService *next;
+    int serviceID;
+};
+
+static PosixService *gServiceList = NULL;
+
+static void RegistrationCallback(mDNS *const m, ServiceRecordSet *const thisRegistration, mStatus status)
+    // mDNS core calls this routine to tell us about the status of 
+    // our registration.  The appropriate action to take depends 
+    // entirely on the value of status.
+{
+    switch (status) {
+
+        case mStatus_NoError:      
+            debugf("Callback: %##s Name Registered",   thisRegistration->RR_SRV.resrec.name->c); 
+            // Do nothing; our name was successfully registered.  We may 
+            // get more call backs in the future.
+            break;
+
+        case mStatus_NameConflict: 
+            debugf("Callback: %##s Name Conflict",     thisRegistration->RR_SRV.resrec.name->c); 
+
+            // In the event of a conflict, this sample RegistrationCallback 
+            // just calls mDNS_RenameAndReregisterService to automatically 
+            // pick a new unique name for the service. For a device such as a 
+            // printer, this may be appropriate.  For a device with a user 
+            // interface, and a screen, and a keyboard, the appropriate response 
+            // may be to prompt the user and ask them to choose a new name for 
+            // the service.
+            //
+            // Also, what do we do if mDNS_RenameAndReregisterService returns an 
+            // error.  Right now I have no place to send that error to.
+
+            status = mDNS_RenameAndReregisterService(m, thisRegistration, mDNSNULL);
+            assert(status == mStatus_NoError);
+            break;
+
+        case mStatus_MemFree:      
+            debugf("Callback: %##s Memory Free",       thisRegistration->RR_SRV.resrec.name->c); 
+
+            // When debugging is enabled, make sure that thisRegistration 
+            // is not on our gServiceList.
+
+            #if !defined(NDEBUG)
+                {
+                    PosixService *cursor;
+
+                    cursor = gServiceList;
+                    while (cursor != NULL) {
+                        assert(&cursor->coreServ != thisRegistration);
+                        cursor = cursor->next;
+                    }
+                }
+            #endif
+            free(thisRegistration);
+            break;
+
+        default:                   
+            debugf("Callback: %##s Unknown Status %ld", thisRegistration->RR_SRV.resrec.name->c, status); 
+            break;
+    }
+}
+
+static int gServiceID = 0;
+
+static mDNSBool CheckThatRichTextNameIsUsable(const char *richTextName, mDNSBool printExplanation)
+    // Checks that richTextName is reasonable 
+    // label and, if it isn't and printExplanation is true, prints 
+    // an explanation of why not.
+{    
+    mDNSBool result = mDNStrue;
+    if (result && strlen(richTextName) > 63) {
+        if (printExplanation) {
+            LogMsg("%s: Service name is too long (must be 63 characters or less)\n", 
+                    SERVICES_FILE);
+        }
+        result = mDNSfalse;
+    }
+    if (result && richTextName[0] == 0) {
+        if (printExplanation) {
+            LogMsg("%s: Service name can't be empty\n", SERVICES_FILE);
+        }
+        result = mDNSfalse;
+    }
+    return result;
+}
+
+static mDNSBool CheckThatServiceTypeIsUsable(const char *serviceType, mDNSBool printExplanation)
+    // Checks that serviceType is a reasonable service type 
+    // label and, if it isn't and printExplanation is true, prints 
+    // an explanation of why not.
+{
+    mDNSBool result;
+
+    result = mDNStrue;
+    if (result && strlen(serviceType) > 63) {
+        if (printExplanation) {
+            LogMsg("%s: Service type is too long (must be 63 characters or less)\n", 
+                    SERVICES_FILE);
+        }
+        result = mDNSfalse;
+    }
+    if (result && serviceType[0] == 0) {
+        if (printExplanation) {
+            LogMsg("%s: Service type can't be empty\n", 
+                    SERVICES_FILE);
+        }
+        result = mDNSfalse;
+    }
+    return result;
+}
+
+static mDNSBool CheckThatPortNumberIsUsable(long portNumber, mDNSBool printExplanation)
+    // Checks that portNumber is a reasonable port number
+    // and, if it isn't and printExplanation is true, prints 
+    // an explanation of why not.
+{
+    mDNSBool result;
+
+    result = mDNStrue;
+    if (result && (portNumber <= 0 || portNumber > 65535)) {
+        if (printExplanation) {
+               LogMsg("%s: Port number must be in range 1..65535\n", 
+                    SERVICES_FILE);
+        }
+        result = mDNSfalse;
+    }
+    return result;
+}
+
+static mDNSBool ReadALine(char *buf, size_t bufSize, FILE *fp)
+// Read a line, skipping over any blank lines or lines starting with '#'
+{
+	mDNSBool good, skip;
+	do {
+		good = (fgets(buf, bufSize, fp) != NULL);
+		skip = (good && (buf[0] == '#'));
+	} while (good && skip);
+	if (good)
+	{
+		int		len = strlen( buf);
+		if ( buf[len - 1] == '\r' || buf[len - 1] == '\n')
+			buf[len - 1] = '\0';
+	}
+    return good;
+}
+
+static mStatus RegisterOneService(const char *  richTextName, 
+                                  const char *  serviceType, 
+                                  const char *  serviceDomain, 
+                                  const mDNSu8  text[],
+                                  mDNSu16       textLen,
+                                  long          portNumber)
+{
+    mStatus             status;
+    PosixService *      thisServ;
+    domainlabel         name;
+    domainname          type;
+    domainname          domain;
+    
+    status = mStatus_NoError;
+    thisServ = (PosixService *) malloc(sizeof(*thisServ));
+    if (thisServ == NULL) {
+        status = mStatus_NoMemoryErr;
+    }
+    if (status == mStatus_NoError) {
+        MakeDomainLabelFromLiteralString(&name,  richTextName);
+        MakeDomainNameFromDNSNameString(&type, serviceType);
+        MakeDomainNameFromDNSNameString(&domain, serviceDomain);
+        status = mDNS_RegisterService(&mDNSStorage, &thisServ->coreServ,
+                &name, &type, &domain,				// Name, type, domain
+                NULL, mDNSOpaque16fromIntVal(portNumber),
+                text, textLen,						// TXT data, length
+                NULL, 0,							// Subtypes
+                mDNSInterface_Any,					// Interface ID
+                RegistrationCallback, thisServ, // Callback and context
+                0);                       //  flags
+    }
+    if (status == mStatus_NoError) {
+        thisServ->serviceID = gServiceID;
+        gServiceID += 1;
+
+        thisServ->next = gServiceList;
+        gServiceList = thisServ;
+
+        if (gMDNSPlatformPosixVerboseLevel > 0) {
+            LogMsg("%s: Registered service %d, name '%s', type '%s', port %ld\n", 
+                    SERVICES_FILE, 
+                    thisServ->serviceID, 
+                    richTextName,
+                    serviceType,
+                    portNumber);
+        }
+    } else {
+        if (thisServ != NULL) {
+            free(thisServ);
+        }
+    }
+    return status;
+}
+
+static const char kDefaultServiceDomain[] = "local.";
+
+static mStatus RegisterServicesInFile(const char *filePath)
+{
+    mStatus     status = mStatus_NoError;
+    FILE *      fp = fopen(filePath, "r");
+    int         junk;
+
+    if (fp == NULL) {
+        status = mStatus_UnknownErr;
+    }
+    if (status == mStatus_NoError) {
+        mDNSBool good = mDNStrue;
+        do {
+			int         ch;
+			char name[256];
+			char type[256];
+			const char *dom = kDefaultServiceDomain;
+			char rawText[1024];
+			mDNSu8  text[sizeof(RDataBody)];
+			unsigned int textLen = 0;
+			char port[256];
+
+            // Skip over any blank lines.
+            do ch = fgetc(fp); while ( ch == '\n' || ch == '\r' );
+            if (ch != EOF) good = (ungetc(ch, fp) == ch);
+
+            // Read three lines, check them for validity, and register the service.
+			good = ReadALine(name, sizeof(name), fp);               
+			if (good) {
+				good = ReadALine(type, sizeof(type), fp);
+			}
+			if (good) {
+				char *p = type;
+				while (*p && *p != ' ') p++;
+				if (*p) {
+					*p = 0;
+					dom = p+1;
+				}
+			}
+			if (good) {
+				good = ReadALine(port, sizeof(port), fp);
+			}
+			if (good) {
+				good =     CheckThatRichTextNameIsUsable(name, mDNSfalse)
+						&& CheckThatServiceTypeIsUsable(type, mDNSfalse)
+						&& CheckThatPortNumberIsUsable(atol(port), mDNSfalse);
+			}
+			if (good) {
+				while (1) {
+					int len;
+					if (!ReadALine(rawText, sizeof(rawText), fp)) break;
+					len = strlen(rawText);
+					if (len <= 255)
+						{
+						unsigned int newlen = textLen + 1 + len;
+						if (len == 0 || newlen >= sizeof(text)) break;
+						text[textLen] = len;
+						mDNSPlatformMemCopy(text + textLen + 1, rawText, len);
+						textLen = newlen;
+						}
+					else
+						LogMsg("%s: TXT attribute too long for name = %s, type = %s, port = %s\n", 
+							SERVICES_FILE, name, type, port);
+				}
+			}
+			if (good) {
+				status = RegisterOneService(name, type, dom, text, textLen, atol(port));
+				if (status != mStatus_NoError) {
+					LogMsg("%s: Failed to register service, name = %s, type = %s, port = %s\n", 
+							SERVICES_FILE, name, type, port);
+					status = mStatus_NoError;       // keep reading
+				}
+			}
+        } while (good && !feof(fp));
+
+        if ( ! good ) {
+            LogMsg("%s: Error reading service file %s\n", SERVICES_FILE, filePath);
+        }
+    }
+
+    if (fp != NULL) {
+        junk = fclose(fp);
+        assert(junk == 0);
+    }
+
+    return status;
+}
+
+static void DeregisterOurServices(void)
+{
+    PosixService *thisServ;
+    int thisServID;
+    
+    while (gServiceList != NULL) {
+        thisServ = gServiceList;
+        gServiceList = thisServ->next;
+
+        thisServID = thisServ->serviceID;
+        
+        mDNS_DeregisterService(&mDNSStorage, &thisServ->coreServ);
+
+        if (gMDNSPlatformPosixVerboseLevel > 0) {
+            LogMsg("%s: Deregistered service %d\n",
+                    SERVICES_FILE, 
+                    thisServ->serviceID);
+        }
+    }
+}
+
 #if _BUILDING_XCODE_PROJECT_
 // If the process crashes, then this string will be magically included in the automatically-generated crash log
 const char *__crashreporter_info__ = mDNSResponderVersionString_SCCS + 5;
diff -Nru mDNSResponder-320.5/mDNSPosix/mDNSPosix.c mdns-patched/mDNSPosix/mDNSPosix.c
--- mDNSResponder-320.5/mDNSPosix/mDNSPosix.c	2011-04-06 22:48:43.000000000 +0000
+++ mdns-patched/mDNSPosix/mDNSPosix.c	2011-12-07 15:33:42.590360143 +0000
@@ -60,6 +60,10 @@
 #include <net/if.h>
 #endif // USES_NETLINK
 
+#ifdef TARGET_OS_LINUX
+#include <sys/ioctl.h>
+#endif
+
 #include "mDNSUNP.h"
 #include "GenLinkedList.h"
 
@@ -84,6 +88,19 @@
 	};
 typedef struct IfChangeRec	IfChangeRec;
 
+// Platform-dependent low-level networking stuff
+
+mDNSlocal int SetupSocket(struct sockaddr *intfAddr, mDNSIPPort port, int interfaceIndex, int *sktPtr, 
+               mDNSIPPort* outport, mDNSBool joinMC);
+mDNSlocal mStatus SetupTCPSocket(TCPSocket *sock, u_short sa_family, mDNSIPPort *port);
+
+mDNSlocal int GetFDTcp(TCPSocket *sock, u_short sa_family);
+
+static struct UDPSocket_struct* PlatformUDPSockets = NULL;
+static struct TCPSocket_struct* PlatformTCPSockets = NULL;
+
+mDNSlocal void DoTcpSocketCallback(TCPSocket *sock);
+
 // Note that static data is initialized to zero in (modern) C.
 static fd_set			gEventFDs;
 static int				gMaxFD;					// largest fd in gEventFDs
@@ -153,7 +170,7 @@
 	PosixNetworkInterface * thisIntf = (PosixNetworkInterface *)(InterfaceID);
 	int sendingsocket = -1;
 
-	(void)src;	// Will need to use this parameter once we implement mDNSPlatformUDPSocket/mDNSPlatformUDPClose
+	//(void)src;	// Will need to use this parameter once we implement mDNSPlatformUDPSocket/mDNSPlatformUDPClose
 
 	assert(m != NULL);
 	assert(msg != NULL);
@@ -170,7 +187,8 @@
 		sin->sin_family         = AF_INET;
 		sin->sin_port           = dstPort.NotAnInteger;
 		sin->sin_addr.s_addr    = dst->ip.v4.NotAnInteger;
-		sendingsocket           = thisIntf ? thisIntf->multicastSocket4 : m->p->unicastSocket4;
+		sendingsocket           = (src) ? (src->sktv4) :
+		                              (thisIntf ? thisIntf->multicastSocket4 : m->p->unicastSocket4);
 		}
 
 #if HAVE_IPV6
@@ -184,7 +202,8 @@
 		sin6->sin6_family         = AF_INET6;
 		sin6->sin6_port           = dstPort.NotAnInteger;
 		sin6->sin6_addr           = *(struct in6_addr*)&dst->ip.v6;
-		sendingsocket             = thisIntf ? thisIntf->multicastSocket6 : m->p->unicastSocket6;
+		sendingsocket             = (src) ? (src->sktv6) :
+		                              (thisIntf ? thisIntf->multicastSocket6 : m->p->unicastSocket6);
 		}
 #endif
 
@@ -214,7 +233,7 @@
 	}
 
 // This routine is called when the main loop detects that data is available on a socket.
-mDNSlocal void SocketDataReady(mDNS *const m, PosixNetworkInterface *intf, int skt)
+mDNSlocal void SocketDataReady(mDNS *const m, PosixNetworkInterface *intf, int skt, mDNSIPPort localPort)
 	{
 	mDNSAddr   senderAddr, destAddr;
 	mDNSIPPort senderPort;
@@ -310,81 +329,467 @@
 
 	if (packetLen >= 0)
 		mDNSCoreReceive(m, &packet, (mDNSu8 *)&packet + packetLen,
-			&senderAddr, senderPort, &destAddr, MulticastDNSPort, InterfaceID);
+			&senderAddr, senderPort, &destAddr, mDNSIPPortIsZero(localPort) ? MulticastDNSPort : localPort, InterfaceID);
 	}
 
-mDNSexport TCPSocket *mDNSPlatformTCPSocket(mDNS * const m, TCPSocketFlags flags, mDNSIPPort * port)
-	{
-	(void)m;			// Unused
-	(void)flags;		// Unused
-	(void)port;			// Unused
-	return NULL;
-	}
+mDNSlocal mStatus SetupTCPSocket(TCPSocket *sock, u_short sa_family, mDNSIPPort *port)
+{
+   const int kOn = 1;  // "on" for setsockopt
+   mStatus err;
+
+   int skt = socket(sa_family, SOCK_STREAM, IPPROTO_TCP);
+   if (skt < 3) {
+      LogMsg("SetupTCPSocket: socket error %d errno %d (%s)", skt, errno, strerror(errno));
+      return mStatus_UnsupportedErr;
+   }
+
+   if (sa_family == AF_INET) {
+      // Bind it
+      struct sockaddr_in addr;
+      mDNSPlatformMemZero(&addr, sizeof(addr));
+      addr.sin_family = AF_INET;
+      addr.sin_port = port->NotAnInteger;
+
+      err = bind(skt, (struct sockaddr*) &addr, sizeof(addr));
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket bind %s", strerror(errno));
+         return err;
+      }
+
+      // Receive interface identifiers
+   	#if defined(IP_PKTINFO)									// Linux
+			err = setsockopt(skt, IPPROTO_IP, IP_PKTINFO, &kOn, sizeof(kOn));
+			if (err < 0) { err = errno; LogMsg("ERROR: SetupTCPSocket setsockopt - IP_PKTINFO"); }
+		#elif defined(IP_RECVDSTADDR) || defined(IP_RECVIF)		// BSD and Solaris
+			#if defined(IP_RECVDSTADDR)
+				err = setsockopt(skt, IPPROTO_IP, IP_RECVDSTADDR, &kOn, sizeof(kOn));
+				if (err < 0) { err = errno; LogMsg("ERROR: SetupTCPSocket setsockopt - IP_RECVDSTADDR"); }
+			#endif
+			#if defined(IP_RECVIF)
+				if (err == 0) {
+					err = setsockopt(skt, IPPROTO_IP, IP_RECVIF, &kOn, sizeof(kOn));
+					if (err < 0) { err = errno; LogMsg("ERROR: SetupTCPSocket setsockopt - IP_RECVIF"); }
+				}
+			#endif
+		#else
+			#warning This platform has no way to get the destination interface information -- will only work for single-homed hosts
+		#endif
+
+      mDNSPlatformMemZero(&addr, sizeof(addr));
+      socklen_t len = sizeof(addr);
+      err = getsockname(skt, (struct sockaddr*) &addr, &len);
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket getsockname - %s", strerror(errno));
+         return err;
+      }
+
+      sock->sktv4 = skt;
+      port->NotAnInteger = addr.sin_port;
+#if HAVE_IPV6
+   } else {
+      // Bind it
+      struct sockaddr_in6 addr6;
+      mDNSPlatformMemZero(&addr6, sizeof(addr6));
+      addr6.sin6_family = AF_INET6;
+      addr6.sin6_port = port->NotAnInteger;
+
+      err = bind(skt, (struct sockaddr*) &addr6, sizeof(addr6));
+
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket bind6 %s", strerror(errno));
+         return err;
+      }
+
+      // We want to receive destination addresses and receive interface identifiers
+      err = setsockopt(skt, IPPROTO_IPV6, IPV6_RECVPKTINFO, &kOn, sizeof(kOn));
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket setsockopt IPV6_RECVPKTINFO %s", strerror(errno));
+         return err;
+      }
+
+      mDNSPlatformMemZero(&addr6, sizeof(addr6));
+      socklen_t len = sizeof(addr6);
+
+      err = getsockname(skt, (struct sockaddr *) &addr6, &len);
+      if (err < 0) {
+         LogMsg("ERROR: SetupTCPSocket getsockname6 - %s", strerror(errno));
+         return err;
+      }
+
+      sock->sktv6 = skt;
+      port->NotAnInteger = addr6.sin6_port;
+#endif
+   }
+
+   return mStatus_NoError;
+}
+
+mDNSlocal void DoTcpSocketCallback(TCPSocket *sock)
+{
+	mDNSBool c = !sock->state.connected;
+	sock->state.connected = 1;
+	sock->callback(sock, sock->context, c, sock->err);
+	// Note: the callback may call CloseConnection here, which frees the context structure!
+}
+
+mDNSexport TCPSocket *mDNSPlatformTCPSocket(mDNS * const m, TCPSocketFlags flags, mDNSIPPort* port)
+{
+	mStatus err;
+	
+   (void)m;
+	
+	TCPSocket *p = mallocL("TCPSocket", sizeof(TCPSocket));
+   if (!p) { LogMsg("mDNSPlatformTCPSocket: memory exhausted"); return(mDNSNULL); }
+   
+   mDNSPlatformMemZero(p, sizeof(TCPSocket));
+   p->sktv4 = -1;
+   p->sktv6 = -1;
+   p->activeSkt = -1;
+   
+   err = SetupTCPSocket(p, AF_INET, port);
+   
+#if HAVE_IPV6
+   if (mStatus_NoError == err) {
+      err = SetupTCPSocket(p, AF_INET6, port);
+      if (err) {
+         mDNSPlatformTCPCloseConnection(p);
+         p = NULL;
+      }
+   }
+#endif
+   
+   if (err)	{
+      LogMsg("mDNSPlatformTCPSocket: socket error errno %d (%s)", errno, strerror(errno));
+      if (NULL != p)
+         freeL("TCPSocket/mDNSPlatformTCPSocket", p);
+      return(mDNSNULL);
+   }
+   
+   p->flags = flags;
+   
+   p->prev = NULL;
+   p->next = PlatformTCPSockets;
+   if (p->next)
+      p->next->prev = p;
+   PlatformTCPSockets = p;
+   
+   LogMsg("TCPSocket created for port %d, sock %d", port->NotAnInteger, p->sktv4);
+   
+   return p;
+}
 
+// Why doesn't mDNSPlatformTCPAccept actually call accept() ?
+// gck: Exactly what I was wondering too! :-)
 mDNSexport TCPSocket *mDNSPlatformTCPAccept(TCPSocketFlags flags, int sd)
-	{
-	(void)flags;		// Unused
-	(void)sd;			// Unused
-	return NULL;
-	}
+{
+   mStatus err = mStatus_NoError;
+
+   TCPSocket *sock = mallocL("TCPSocket/mDNSPlatformTCPAccept", sizeof(TCPSocket));
+   if (NULL == sock) {
+      LogMsg("mDNSPlatformTCPAccept: memory exhausted.");
+      return mDNSNULL;
+   }
+
+   mDNSPlatformMemZero(sock, sizeof(*sock));
+   sock->flags = flags;
+   sock->activeSkt = sd;
+   
+   // we need to find out if the connected socket is IPv4 or IPv6, since the
+   // function parameters won't tell us
+   struct sockaddr addr;
+   mDNSPlatformMemZero(&addr, sizeof(addr));
+	socklen_t len = sizeof(addr);
+   err = getsockname(sd, &addr, &len);
+   
+   if (AF_INET == addr.sa_family)
+      sock->sktv4 = sd;
+   else
+      sock->sktv6 = sd;
+
+   if (flags & kTCPSocketFlags_UseTLS) {
+      LogMsg("mDNSPlatformTCPAccept: ERROR kTCPSocketFlags_UseTLS not supported!");
+      err = mStatus_UnsupportedErr;
+   }
+   
+   if (err) {
+      freeL("TCPSocket/mDNSPlatformTCPAccept", sock);
+      sock = mDNSNULL;
+   }
+   
+   return sock;
+}
+
+mDNSlocal int GetFDTcp(TCPSocket *sock, u_short sa_family)
+{
+   return (AF_INET == sa_family) ? sock->sktv4 : sock->sktv6;
+} 
 
 mDNSexport int mDNSPlatformTCPGetFD(TCPSocket *sock)
-	{
-	(void)sock;			// Unused
-	return -1;
+{
+   // return the active socket, otherwise, return the IPv4 socket, else return IPv6
+   if (sock->activeSkt > -1)
+      return sock->activeSkt;
+   
+   int fd = GetFDTcp(sock, AF_INET);
+   
+   return (fd > -1) ? fd : GetFDTcp(sock, AF_INET6);
+}
+
+mDNSexport mStatus mDNSPlatformTCPConnect(TCPSocket *sock, const mDNSAddr *dst, mDNSOpaque16 dstport, domainname *hostname,
+                        mDNSInterfaceID InterfaceID, TCPConnectionCallback callback, void *context)
+{
+	struct sockaddr_storage ss;
+   
+#if HAVE_IPV6
+   int* s = (mDNSAddrType_IPv4 == dst->type) ? &sock->sktv4 : &sock->sktv6;
+#else
+   int* s = &sock->sktv4;
+#endif
+
+	sock->err         = mStatus_NoError;
+   sock->context     = context;
+   sock->callback    = callback;
+   
+   if (sock->state.connected)
+      LogMsg("mDNSPlatformTCPConnect: socket already connected!");
+
+	if (NULL != hostname) {
+	   LogMsg("mDNSPlatformTCPConnect: hostname %##s", hostname->c);
+	   AssignDomainName(&sock->hostname, hostname);
+	}
+
+	if (dst->type == mDNSAddrType_IPv4) {
+		struct sockaddr_in *saddr = (struct sockaddr_in *)&ss;
+		mDNSPlatformMemZero(saddr, sizeof(*saddr));
+		saddr->sin_family      = AF_INET;
+		saddr->sin_port        = dstport.NotAnInteger;
+		saddr->sin_addr.s_addr = dst->ip.v4.NotAnInteger;
+#ifndef NOT_HAVE_SA_LEN
+		saddr->sin_len         = sizeof(*saddr);
+#endif
+	} else {
+		struct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)&ss;
+		mDNSPlatformMemZero(saddr6, sizeof(*saddr6));
+		saddr6->sin6_family      = AF_INET6;
+		saddr6->sin6_port        = dstport.NotAnInteger;
+		saddr6->sin6_addr        = *(struct in6_addr *)&dst->ip.v6;
+#ifndef NOT_HAVE_SA_LEN
+		saddr6->sin6_len         = sizeof(*saddr6);
+#endif
 	}
 
-mDNSexport mStatus mDNSPlatformTCPConnect(TCPSocket *sock, const mDNSAddr *dst, mDNSOpaque16 dstport, domainname *hostname, mDNSInterfaceID InterfaceID,
-										  TCPConnectionCallback callback, void *context)
-	{
-	(void)sock;			// Unused
-	(void)dst;			// Unused
-	(void)dstport;		// Unused
-	(void)hostname;     // Unused
-	(void)InterfaceID;	// Unused
-	(void)callback;		// Unused
-	(void)context;		// Unused
-	return(mStatus_UnsupportedErr);
+	if (fcntl(*s, F_SETFL, fcntl(*s, F_GETFL, 0) | O_NONBLOCK) < 0) { // set non-blocking
+		LogMsg("mDNSPlatformTCPConnect: ERROR setsockopt O_NONBLOCK - %s", strerror(errno));
+		return mStatus_UnknownErr;
 	}
 
+	// We bind to the interface and all subsequent packets including the SYN will be sent out
+	// on this interface
+	//
+	// Note: If we are in Active Directory domain, we may try TCP (if the response can't fit in
+	// UDP). mDNSInterface_Unicast indicates this case and not a valid interface.
+	if (InterfaceID && InterfaceID != mDNSInterface_Unicast) {
+	   PosixNetworkInterface* intf = (PosixNetworkInterface *)(InterfaceID);
+	   
+	   // gck: SO_BINDTODEVICE is a linux-ism, but that's the only thing I'm concerned about here.
+	   struct ifreq ifr;
+      memset(&ifr, 0, sizeof(struct ifreq));
+      strncpy(ifr.ifr_name, intf->intfName, sizeof(ifr.ifr_name));
+      ioctl(*s, SIOCGIFINDEX, &ifr);
+
+      int e = setsockopt(*s, SOL_SOCKET, SO_BINDTODEVICE, (void*)&ifr, sizeof(struct ifreq));
+      LogMsg("mDNSPlatformTCPConnect: binding to device %s returned %d", ifr.ifr_name, e);
+	}
+
+   sock->activeSkt = *s;
+
+   if (connect(*s, (struct sockaddr*)&ss, sizeof(struct sockaddr)) < 0) {
+      switch (errno) {
+         case EINPROGRESS:
+            return mStatus_ConnPending;
+         default:
+            LogMsg("ERROR: mDNSPlatformTCPConnect - connect failed: socket %d: Error %d (%s)", *s, errno, strerror(errno));
+            return mStatus_ConnFailed;
+      }
+   }
+   
+   LogMsg("NOTE: mDNSPlatformTCPConnect completed synchronously");
+   return mStatus_NoError;
+}
+
 mDNSexport void mDNSPlatformTCPCloseConnection(TCPSocket *sock)
-	{
-	(void)sock;			// Unused
-	}
+{
+   if (sock) {
+      if (sock->activeSkt > -1) close(sock->activeSkt);
+      if (sock->sktv4 > -1) close(sock->sktv4);
+#if HAVE_IPV6
+      if (sock->sktv6 > -1) close(sock->sktv6);
+#endif
 
-mDNSexport long mDNSPlatformReadTCP(TCPSocket *sock, void *buf, unsigned long buflen, mDNSBool * closed)
-	{
-	(void)sock;			// Unused
-	(void)buf;			// Unused
-	(void)buflen;		// Unused
-	(void)closed;		// Unused
-	return 0;			
-	}
+      if (sock->prev)
+         sock->prev->next = sock->next;
+      else
+         PlatformTCPSockets = sock->next;
 
-mDNSexport long mDNSPlatformWriteTCP(TCPSocket *sock, const char *msg, unsigned long len)
-	{
-	(void)sock;			// Unused
-	(void)msg;			// Unused
-	(void)len;			// Unused
-	return 0;
-	}
+      if (sock->next)
+         sock->next->prev = sock->prev;
 
-mDNSexport UDPSocket *mDNSPlatformUDPSocket(mDNS * const m, mDNSIPPort port)
-	{
-	(void)m;			// Unused
-	(void)port;			// Unused
-	return NULL;
-	}
+      LogMsg("Closed TCP socket %d", sock->sktv4);
 
-mDNSexport void           mDNSPlatformUDPClose(UDPSocket *sock)
-	{
-	(void)sock;			// Unused
+      freeL("TCPSocket/mDNSPlatformTCPCloseConnection", sock);
+   }
+}
+
+mDNSexport long mDNSPlatformReadTCP(TCPSocket *sock, void *buf, unsigned long buflen, mDNSBool * closed)
+{
+   size_t nread = 0;
+   int fd = (sock->activeSkt > -1) ? sock->activeSkt : mDNSPlatformTCPGetFD(sock);
+   
+   if (NULL != closed)
+      *closed = mDNSfalse;
+	
+	if (sock->flags & kTCPSocketFlags_UseTLS) {
+      LogMsg("ERROR: mDNSPlatformReadTCP kTCPSocketFlags_UseTLS not supported!");
+      nread = -1;
+      if (NULL != closed)
+         *closed = mDNStrue;
+	} else {
+      static int CLOSEDcount = 0;
+      static int EAGAINcount = 0;
+      
+      nread = recv(fd, buf, buflen, 0);
+      
+      if (nread > 0) {
+         CLOSEDcount = EAGAINcount = 0;
+      } else if (0 == nread) {
+         if (NULL != closed)
+            *closed = mDNStrue;
+         if ((++CLOSEDcount % 1000) == 0)
+            LogMsg("ERROR: mDNSPlatformReadTCP - recv %d got CLOSED %d times", sock->activeSkt, CLOSEDcount);
+      } else if (ECONNRESET == errno) {   // from here on, nread must be negative
+         nread = 0;
+         if (NULL != closed)
+            *closed = mDNStrue;
+      } else if (EAGAIN == errno) {
+         nread = 0;
+         if ((++EAGAINcount % 1000) == 0)
+            LogMsg("ERROR: mDNSPlatformReadTCP - recv %d got EAGAIN %d times", sock->activeSkt, EAGAINcount);
+      } else {
+         nread = -1;
+         LogMsg("ERROR: mDNSPlatformReadTCP - recv: %d (%s)", errno, strerror(errno));
+      }
 	}
+
+   return nread;
+}
+
+mDNSexport long mDNSPlatformWriteTCP(TCPSocket *sock, const char *msg, unsigned long len)
+{
+   int nsent;
+   int fd = (sock->activeSkt > -1) ? sock->activeSkt : mDNSPlatformTCPGetFD(sock);
+
+   if (sock->flags & kTCPSocketFlags_UseTLS) {
+      LogMsg("ERROR: mDNSPlatformWriteTCP kTCPSocketFlags_UseTLS not supported!");
+      nsent = -1;
+   } else {
+      nsent = send(fd, msg, len, 0);
+      
+      if (nsent < 0) {
+         if (EAGAIN == errno)
+            nsent = 0;
+         else {
+            LogMsg("ERROR: mDNSPlatformWriteTCP - send %s", strerror(errno));
+            nsent = -1;
+         }
+      }
+   }
+   
+   return nsent;
+}
+
+mDNSexport UDPSocket *mDNSPlatformUDPSocket(mDNS * const m, mDNSIPPort requestedPort)
+{
+   mStatus err;
+   mDNSIPPort port = requestedPort;
+   mDNSBool randomizePort = mDNSIPPortIsZero(requestedPort);
+   struct sockaddr sa;
+   int i = 1000; // Try at most 1000 times to get a unique random port
+   UDPSocket *p = mallocL("UDPSocket", sizeof(UDPSocket));
+   if (!p) { LogMsg("mDNSPlatformUDPSocket: memory exhausted"); return(mDNSNULL); }
+   mDNSPlatformMemZero(p, sizeof(UDPSocket));
+   p->port  = zeroIPPort;
+   p->sktv4 = -1;
+   p->sktv6 = -1;
+
+   (void)m;
+
+   do
+   	{
+   	// The kernel doesn't do cryptographically strong random port allocation, so we do it ourselves here
+   	if (randomizePort) port = mDNSOpaque16fromIntVal(0xC000 + mDNSRandom(0x3FFF));
+      mDNSPlatformMemZero(&sa, sizeof(struct sockaddr));
+      sa.sa_family = AF_INET;
+   	err = SetupSocket(&sa, port, 0, &p->sktv4, &p->port, mDNSSameIPPort(requestedPort, NATPMPAnnouncementPort));
+   	/* TODO: make me work!
+   	if (!err)
+   		{
+		   mDNSPlatformMemZero(&sa, sizeof(struct sockaddr));
+         sa.sa_family = AF_INET6;
+   		err = SetupSocket(&sa, port, 0, &p->sktv6, &p->port, 0);
+   		if (err) { close(p->sktv4); p->sktv4 = -1; }
+   		}*/
+   	i--;
+   	} while (err == EADDRINUSE && randomizePort && i);
+
+   if (err)
+   	{
+   	// In customer builds we don't want to log failures with port 5351, because this is a known issue
+   	// of failing to bind to this port when Internet Sharing has already bound to it
+   	// We also don't want to log about port 5350, due to a known bug when some other
+   	// process is bound to it.
+   	if (mDNSSameIPPort(requestedPort, NATPMPPort) || mDNSSameIPPort(requestedPort, NATPMPAnnouncementPort))
+   		LogInfo("mDNSPlatformUDPSocket: SetupSocket %d failed error %d errno %d (%s)", mDNSVal16(requestedPort), err, errno, strerror(errno));
+   	else LogMsg("mDNSPlatformUDPSocket: SetupSocket %d failed error %d errno %d (%s)", mDNSVal16(requestedPort), err, errno, strerror(errno));
+   	freeL("UDPSocket", p);
+   	return(mDNSNULL);
+   	}
+   
+   p->prev = NULL;
+   p->next = PlatformUDPSockets;
+   if (p->next)
+      p->next->prev = p;
+   PlatformUDPSockets = p;
+   
+   return(p);
+}
+
+mDNSexport void mDNSPlatformUDPClose(UDPSocket *sock)
+{
+   if (sock->sktv4 > -1) {
+      close(sock->sktv4);
+      sock->sktv4 = -1;
+   }
+   if (sock->sktv6 > -1) {
+      close(sock->sktv6);
+      sock->sktv6 = -1;
+   }
+   
+   if (sock->prev)
+      sock->prev->next = sock->next;
+   else
+      PlatformUDPSockets = sock->next;
+   
+   if (sock->next)
+      sock->next->prev = sock->prev;
+   
+   freeL("UDPSocket", sock);
+}
 	
 mDNSexport void mDNSPlatformUpdateProxyList(mDNS *const m, const mDNSInterfaceID InterfaceID)
 	{
 	(void)m;			// Unused
 	(void)InterfaceID;			// Unused
+	LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 	}
 
 mDNSexport void mDNSPlatformSendRawPacket(const void *const msg, const mDNSu8 *const end, mDNSInterfaceID InterfaceID)
@@ -392,6 +797,7 @@
 	(void)msg;			// Unused
 	(void)end;			// Unused
 	(void)InterfaceID;			// Unused
+	LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 	}
 	
 mDNSexport void mDNSPlatformSetLocalAddressCacheEntry(mDNS *const m, const mDNSAddr *const tpa, const mDNSEthAddr *const tha, mDNSInterfaceID InterfaceID)
@@ -400,15 +806,18 @@
 	(void)tpa;			// Unused
 	(void)tha;			// Unused
 	(void)InterfaceID;			// Unused
+	LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 	}	
 
 mDNSexport mStatus mDNSPlatformTLSSetupCerts(void)
 	{
+	LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 	return(mStatus_UnsupportedErr);
 	}
 	
 mDNSexport void mDNSPlatformTLSTearDownCerts(void)
 	{
+	LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 	}
 
 mDNSexport void mDNSPlatformSetAllowSleep(mDNS *const m, mDNSBool allowSleep, const char *reason)
@@ -416,6 +825,7 @@
 	(void) m;
 	(void) allowSleep;
 	(void) reason;
+	LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 	}
 
 #if COMPILER_LIKES_PRAGMA_MARK
@@ -445,20 +855,108 @@
 	(void) BrowseDomains;
 	}
 
+#ifdef TARGET_OS_LINUX
+#include <ctype.h>
+#endif
+
 mDNSexport mStatus mDNSPlatformGetPrimaryInterface(mDNS * const m, mDNSAddr * v4, mDNSAddr * v6, mDNSAddr * router)
+#ifdef TARGET_OS_LINUX
+{
+   unsigned long d, g;
+   char buf[256];
+   int line = 0;
+   FILE * f;
+   char * p;
+
+   (void)m;
+
+   // TODO: where/how to get ipv6 address?
+   if (v6)
+      *v6 = zeroAddr;
+
+   f = fopen("/proc/net/route", "r");
+
+   if (!f)
+      return mStatus_UnknownErr;
+
+   while(fgets(buf, sizeof(buf), f)) {
+      if(line > 0) {  /* skip the first line */
+         p = buf;
+
+         /* skip the interface name */
+         while(*p && !isspace(*p))
+            p++;
+
+         *p++ = '\0';
+
+         while(*p && isspace(*p))
+            p++;
+
+         if(sscanf(p, "%lx%lx", &d, &g)==2) {
+            if(d == 0 && g != 0) {
+               if (router) {
+                  router->type = mDNSAddrType_IPv4;
+                  router->ip.v4.NotAnInteger = g;
+               }
+               fclose(f);
+               
+               int sock = socket(AF_INET, SOCK_DGRAM, 0);
+               if (sock > -1) {
+                  struct sockaddr_in sin;
+                  socklen_t socklen = sizeof(struct sockaddr_in);
+                  
+                  mDNSPlatformMemZero(&sin, socklen);
+                  sin.sin_port = htons(3000);
+                  sin.sin_addr.s_addr = INADDR_ANY;
+                  sin.sin_family = AF_INET;
+                  
+                  
+                  if (connect(sock, (struct sockaddr*)&sin, socklen) >= 0 &&
+                      getsockname(sock, (struct sockaddr*)&sin, &socklen) >= 0) {
+                     
+                     if (v4) {
+                        v4->type = mDNSAddrType_IPv4;
+                        v4->ip.v4.NotAnInteger = sin.sin_addr.s_addr;
+                     }
+                     
+                     return mStatus_NoError;
+                  }
+                  
+                  close(sock);
+               }
+               
+               return mStatus_UnknownErr;
+            }
+         }
+      }
+
+   line++;
+   }
+
+   /* default route not found ! */
+   if (f)
+      fclose(f);
+
+   return mStatus_UnknownErr;
+}
+#else
 	{
 	(void) m;
 	(void) v4;
 	(void) v6;
 	(void) router;
 
+   LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
+
 	return mStatus_UnsupportedErr;
 	}
+#endif
 
 mDNSexport void mDNSPlatformDynDNSHostNameStatusChanged(const domainname *const dname, const mStatus status)
 	{
 	(void) dname;
 	(void) status;
+	LogMsg("%s:%s(): NOT IMPLEMENTED!", __FILE__, __FUNCTION__);
 	}
 
 #if COMPILER_LIKES_PRAGMA_MARK
@@ -593,13 +1091,15 @@
 // Sets up a send/receive socket.
 // If mDNSIPPort port is non-zero, then it's a multicast socket on the specified interface
 // If mDNSIPPort port is zero, then it's a randomly assigned port number, used for sending unicast queries
-mDNSlocal int SetupSocket(struct sockaddr *intfAddr, mDNSIPPort port, int interfaceIndex, int *sktPtr)
+mDNSlocal int SetupSocket(struct sockaddr *intfAddr, mDNSIPPort port, int interfaceIndex, int *sktPtr,
+                           mDNSIPPort* outport, mDNSBool joinMC)
 	{
 	int err = 0;
 	static const int kOn = 1;
 	static const int kIntTwoFiveFive = 255;
 	static const unsigned char kByteTwoFiveFive = 255;
-	const mDNSBool JoinMulticastGroup = (port.NotAnInteger != 0);
+	const mDNSBool JoinMulticastGroup = joinMC; // was: (port.NotAnInteger != 0);
+   const mDNSBool isNATPMPAnnouncePort = mDNSSameIPPort(port, NATPMPAnnouncementPort);
 	
 	(void) interfaceIndex;	// This parameter unused on plaforms that don't have IPv6
 	assert(intfAddr != NULL);
@@ -665,7 +1165,8 @@
 		// Add multicast group membership on this interface
 		if (err == 0 && JoinMulticastGroup)
 			{
-			imr.imr_multiaddr.s_addr = AllDNSLinkGroup_v4.ip.v4.NotAnInteger;
+			imr.imr_multiaddr.s_addr = isNATPMPAnnouncePort ? AllHosts_v4.NotAnInteger :  
+			                              AllDNSLinkGroup_v4.ip.v4.NotAnInteger;
 			imr.imr_interface        = ((struct sockaddr_in*)intfAddr)->sin_addr;
 			err = setsockopt(*sktPtr, IPPROTO_IP, IP_ADD_MEMBERSHIP, &imr, sizeof(imr));
 			if (err < 0) { err = errno; perror("setsockopt - IP_ADD_MEMBERSHIP"); }
@@ -700,9 +1201,10 @@
 			{
 			bindAddr.sin_family      = AF_INET;
 			bindAddr.sin_port        = port.NotAnInteger;
-			bindAddr.sin_addr.s_addr = INADDR_ANY; // Want to receive multicasts AND unicasts on this socket
+			bindAddr.sin_addr.s_addr = isNATPMPAnnouncePort ? AllHosts_v4.NotAnInteger : INADDR_ANY; // Want to receive multicasts AND unicasts on this socket
 			err = bind(*sktPtr, (struct sockaddr *) &bindAddr, sizeof(bindAddr));
 			if (err < 0) { err = errno; perror("bind"); fflush(stderr); }
+			if (outport) outport->NotAnInteger = bindAddr.sin_port;
 			}
 		} // endif (intfAddr->sa_family == AF_INET)
 
@@ -866,10 +1368,10 @@
 	if (err == 0)
 		{
 		if (alias->multicastSocket4 == -1 && intfAddr->sa_family == AF_INET)
-			err = SetupSocket(intfAddr, MulticastDNSPort, intf->index, &alias->multicastSocket4);
+			err = SetupSocket(intfAddr, MulticastDNSPort, intf->index, &alias->multicastSocket4, NULL, 1);
 #if HAVE_IPV6
 		else if (alias->multicastSocket6 == -1 && intfAddr->sa_family == AF_INET6)
-			err = SetupSocket(intfAddr, MulticastDNSPort, intf->index, &alias->multicastSocket6);
+			err = SetupSocket(intfAddr, MulticastDNSPort, intf->index, &alias->multicastSocket6, NULL, 1);
 #endif
 		}
 
@@ -1227,11 +1729,11 @@
 
 	sa.sa_family = AF_INET;
 	m->p->unicastSocket4 = -1;
-	if (err == mStatus_NoError) err = SetupSocket(&sa, zeroIPPort, 0, &m->p->unicastSocket4);
+	if (err == mStatus_NoError) err = SetupSocket(&sa, zeroIPPort, 0, &m->p->unicastSocket4, NULL, 0);
 #if HAVE_IPV6
 	sa.sa_family = AF_INET6;
 	m->p->unicastSocket6 = -1;
-	if (err == mStatus_NoError) err = SetupSocket(&sa, zeroIPPort, 0, &m->p->unicastSocket6);
+	if (err == mStatus_NoError) err = SetupSocket(&sa, zeroIPPort, 0, &m->p->unicastSocket6, NULL, 0);
 #endif
 
 	// Tell mDNS core about the network interfaces on this machine.
@@ -1426,6 +1928,24 @@
 		info = (PosixNetworkInterface *)(info->coreIntf.next);
 		}
 
+   UDPSocket* udpSock = PlatformUDPSockets;
+   while (udpSock) {
+      if (udpSock->sktv4 > -1) mDNSPosixAddToFDSet(nfds, readfds, udpSock->sktv4);
+#if HAVE_IPV6
+      if (udpSock->sktv6 > -1) mDNSPosixAddToFDSet(nfds, readfds, udpSock->sktv6);
+#endif
+      
+      udpSock = udpSock->next;
+   }
+   
+   TCPSocket* tcpSock = PlatformTCPSockets;
+   while (tcpSock) {
+      int fd = mDNSPlatformTCPGetFD(tcpSock);
+      if (fd > -1) mDNSPosixAddToFDSet(nfds, readfds, fd);
+
+      tcpSock = tcpSock->next;
+   }
+
 	// 3. Calculate the time remaining to the next scheduled event (in struct timeval format)
 	ticks = nextevent - mDNS_TimeNow(m);
 	if (ticks < 1) ticks = 1;
@@ -1448,13 +1968,13 @@
 	if (m->p->unicastSocket4 != -1 && FD_ISSET(m->p->unicastSocket4, readfds))
 		{
 		FD_CLR(m->p->unicastSocket4, readfds);
-		SocketDataReady(m, NULL, m->p->unicastSocket4);
+		SocketDataReady(m, NULL, m->p->unicastSocket4, zeroIPPort);
 		}
 #if HAVE_IPV6
 	if (m->p->unicastSocket6 != -1 && FD_ISSET(m->p->unicastSocket6, readfds))
 		{
 		FD_CLR(m->p->unicastSocket6, readfds);
-		SocketDataReady(m, NULL, m->p->unicastSocket6);
+		SocketDataReady(m, NULL, m->p->unicastSocket6, zeroIPPort);
 		}
 #endif
 
@@ -1463,17 +1983,50 @@
 		if (info->multicastSocket4 != -1 && FD_ISSET(info->multicastSocket4, readfds))
 			{
 			FD_CLR(info->multicastSocket4, readfds);
-			SocketDataReady(m, info, info->multicastSocket4);
+			SocketDataReady(m, info, info->multicastSocket4, zeroIPPort);
 			}
 #if HAVE_IPV6
 		if (info->multicastSocket6 != -1 && FD_ISSET(info->multicastSocket6, readfds))
 			{
 			FD_CLR(info->multicastSocket6, readfds);
-			SocketDataReady(m, info, info->multicastSocket6);
+			SocketDataReady(m, info, info->multicastSocket6, zeroIPPort);
 			}
 #endif
 		info = (PosixNetworkInterface *)(info->coreIntf.next);
 		}
+		
+		UDPSocket* udpSock = PlatformUDPSockets;
+      while (udpSock) {
+         if (udpSock->sktv4 > -1 && FD_ISSET(udpSock->sktv4, readfds)) {
+            FD_CLR(udpSock->sktv4, readfds);
+            SocketDataReady(m, NULL, udpSock->sktv4, udpSock->port);
+         }
+#if HAVE_IPV6
+         if (udpSock->sktv6 > -1 && FD_ISSET(udpSock->sktv6, readfds)) {
+            FD_CLR(udpSock->sktv6, readfds);
+            SocketDataReady(m, NULL, udpSock->sktv6, udpSock->port);
+         }
+#endif
+
+         udpSock = udpSock->next;
+      }
+      
+		TCPSocket* tcpSock = PlatformTCPSockets;
+      while (tcpSock) {
+         int fd = mDNSPlatformTCPGetFD(tcpSock);
+         if (fd > -1 && FD_ISSET(fd, readfds)) {
+            FD_CLR(fd, readfds);
+            
+            if (tcpSock->flags & kTCPSocketFlags_UseTLS) {
+               LogMsg("ERROR: mDNSPosixProcessFDSet kTCPSocketFlags_UseTLS not supported!");
+               tcpSock->err = mStatus_UnsupportedErr;
+            }
+            
+            DoTcpSocketCallback(tcpSock);
+         }
+
+         tcpSock = tcpSock->next;
+      }
 	}
 
 // update gMaxFD
@@ -1614,3 +2167,70 @@
 
 	return mStatus_NoError;
 	}
+
+#ifdef TARGET_OS_LINUX
+int mDNS_PlatformGetGateway(const char* ifname, mDNSAddr* v4, mDNSAddr* v6)
+{
+   unsigned long d, g;
+   char buf[256];
+   int line = 0;
+   FILE * f;
+   char * p;
+
+   // TODO: how to get v6 address?
+   if (v6)
+      *v6 = zeroAddr;
+
+   f = fopen("/proc/net/route", "r");
+
+   if (!f)
+      return mStatus_UnknownErr;
+
+   while(fgets(buf, sizeof(buf), f)) {
+      if(line > 0) {  /* skip the first line */
+         p = buf;
+
+         /* skip the interface name */
+         while(*p && !isspace(*p))
+            p++;
+
+         if (ifname) {
+            *p = '\0';
+            if (strcmp(ifname, buf))
+               continue;
+            else
+               *p = ' ';
+         }
+
+         while(*p && isspace(*p))
+            p++;
+
+         // TODO: how to actually get the router address if it's NOT the
+         // default route (e.g. 0.0.0.0)
+         if(sscanf(p, "%lx%lx", &d, &g)==2) {
+            if(d == 0 && g != 0) { /* default */
+               if (v4) {
+                  v4->type = mDNSAddrType_IPv4;
+                  v4->ip.v4.NotAnInteger = g;
+               }
+               fclose(f);
+               return mStatus_NoError;
+            }
+         }
+      }
+
+   line++;
+   }
+
+   /* default route not found ! */
+   if (f)
+      fclose(f);
+
+   return mStatus_UnknownErr;
+}
+#else
+int mDNS_PlatformGetGateway(const char* ifname, in_addr_t * addr)
+{
+   return -1;
+}
+#endif
\ No newline at end of file
diff -Nru mDNSResponder-320.5/mDNSPosix/mDNSPosix.h mdns-patched/mDNSPosix/mDNSPosix.h
--- mDNSResponder-320.5/mDNSPosix/mDNSPosix.h	2009-08-11 01:13:47.000000000 +0000
+++ mdns-patched/mDNSPosix/mDNSPosix.h	2011-12-07 15:33:42.360350046 +0000
@@ -56,6 +56,36 @@
 #endif
 	};
 
+// Platform-specific low-level networking code
+
+struct UDPSocket_struct {
+  mDNSIPPort port;
+  int sktv4;
+  int sktv6;
+  
+  struct UDPSocket_struct* next;
+  struct UDPSocket_struct* prev;
+};
+
+struct TCPSocket_struct {
+   TCPSocketFlags flags; // MUST BE FIRST FIELD -- mDNSCore expects every TCPSocket_struct to begin with TCPSocketFlags flags
+   int sktv4;
+   int sktv6;
+   int activeSkt;
+   
+   mStatus                 err;
+   domainname              hostname;
+   TCPConnectionCallback   callback;
+   void*                   context;
+   
+   struct	{
+       unsigned connected:1;
+   } state;
+   
+   struct TCPSocket_struct* next;
+   struct TCPSocket_struct* prev;
+};
+
 #define uDNS_SERVERS_FILE "/etc/resolv.conf"
 extern int ParseDNSServers(mDNS *m, const char *filePath);
 extern mStatus mDNSPlatformPosixRefreshInterfaceList(mDNS *const m);
@@ -78,6 +108,8 @@
 extern mStatus mDNSPosixIgnoreSignalInEventLoop( int signum);
 extern mStatus mDNSPosixRunEventLoopOnce( mDNS *m, const struct timeval *pTimeout, sigset_t *pSignalsReceived, mDNSBool *pDataDispatched);
 
+int mDNS_PlatformGetGateway(const char* ifname, mDNSAddr* v4, mDNSAddr* v6);
+
 #ifdef  __cplusplus
     }
 #endif
diff -Nru mDNSResponder-320.5/mDNSShared/PlatformCommon.c mdns-patched/mDNSShared/PlatformCommon.c
--- mDNSResponder-320.5/mDNSShared/PlatformCommon.c	2011-04-11 22:54:35.000000000 +0000
+++ mdns-patched/mDNSShared/PlatformCommon.c	2011-12-07 15:33:43.130383861 +0000
@@ -21,6 +21,7 @@
 #include <errno.h>				// Needed for errno etc.
 #include <sys/socket.h>			// Needed for socket() etc.
 #include <netinet/in.h>			// Needed for sockaddr_in
+#include <stdlib.h>           // Needed for strtol()
 #include <syslog.h>
 
 #include "mDNSEmbeddedAPI.h"	// Defines the interface provided to the client layer above
@@ -102,20 +103,31 @@
 mDNSexport void ReadDDNSSettingsFromConfFile(mDNS *const m, const char *const filename, domainname *const hostname, domainname *const domain, mDNSBool *DomainDiscoveryDisabled)
 	{
 	char buf[MAX_ESCAPED_DOMAIN_NAME] = "";
+	char knn[MAX_ESCAPED_DOMAIN_NAME] = "";
+   domainname keyName;
+   mDNSIPPort port;
+   keyName.c[0] = knn[0] = 0;
 	mStatus err;
 	FILE *f = fopen(filename, "r");
 
     if (hostname)                 hostname->c[0] = 0;
     if (domain)                   domain->c[0] = 0;
 	if (DomainDiscoveryDisabled) *DomainDiscoveryDisabled = mDNSfalse;
+	
+   port = UnicastDNSPort;
 
 	if (f)
 		{
 		if (DomainDiscoveryDisabled && GetConfigOption(buf, "DomainDiscoveryDisabled", f) && !strcasecmp(buf, "true")) *DomainDiscoveryDisabled = mDNStrue;
 		if (hostname && GetConfigOption(buf, "hostname", f) && !MakeDomainNameFromDNSNameString(hostname, buf)) goto badf;
 		if (domain && GetConfigOption(buf, "zone", f) && !MakeDomainNameFromDNSNameString(domain, buf)) goto badf;
+		if (GetConfigOption(buf, "port", f)) {
+         port = mDNSOpaque16fromIntVal(strtol(buf, (char **)NULL, 10));
+		}
 		buf[0] = 0;
 		GetConfigOption(buf, "secret-64", f);  // failure means no authentication
+		if (GetConfigOption(knn, "secret-name", f))
+         MakeDomainNameFromDNSNameString(&keyName, knn);
 		fclose(f);
 		f = NULL;
 		}
@@ -129,7 +141,7 @@
 		{
 		DomainAuthInfo *info = (DomainAuthInfo*)mDNSPlatformMemAllocate(sizeof(*info));
 		// for now we assume keyname = service reg domain and we use same key for service and hostname registration
-		err = mDNS_SetSecretForDomain(m, info, domain, domain, buf, NULL, 0, NULL);
+		err = mDNS_SetSecretForDomain(m, info, domain, (keyName.c[0] ? &keyName : domain), buf, hostname, &port, NULL);
 		if (err) LogMsg("ERROR: mDNS_SetSecretForDomain returned %d for domain %##s", err, domain->c);
 		}
 
diff -Nru mDNSResponder-320.5/mDNSShared/dnsextd.c mdns-patched/mDNSShared/dnsextd.c
--- mDNSResponder-320.5/mDNSShared/dnsextd.c	2011-04-11 22:54:35.000000000 +0000
+++ mdns-patched/mDNSShared/dnsextd.c	2011-12-07 15:33:43.110382983 +0000
@@ -1074,7 +1074,8 @@
 
 	mDNSPlatformMemZero( &d->addr, sizeof( d->addr ) );
 	d->addr.sin_addr.s_addr	= zerov4Addr.NotAnInteger;
-	d->addr.sin_port		= UnicastDNSPort.NotAnInteger;
+	//d->addr.sin_port=mDNSOpaque16fromIntVal(7030).NotAnInteger;         //TODOFIX: 
+   d->addr.sin_port		= UnicastDNSPort.NotAnInteger;
 	d->addr.sin_family		= AF_INET;
 #ifndef NOT_HAVE_SA_LEN
 	d->addr.sin_len			= sizeof( d->addr );
@@ -1085,7 +1086,8 @@
 	mDNSPlatformMemZero(&d->ns_addr, sizeof(d->ns_addr));
 	d->ns_addr.sin_family	= AF_INET;
 	inet_pton( AF_INET, LOOPBACK, &d->ns_addr.sin_addr );
-	d->ns_addr.sin_port		= NSIPCPort.NotAnInteger;
+   d->ns_addr.sin_port		= NSIPCPort.NotAnInteger;
+	//d->ns_addr.sin_port		= mDNSOpaque16fromIntVal(53).NotAnInteger;    //TODOFIX:
 #ifndef NOT_HAVE_SA_LEN
 	d->ns_addr.sin_len		= sizeof( d->ns_addr );
 #endif
@@ -1240,8 +1242,6 @@
 
 	// set up socket on which we receive private requests
 
-	self->llq_tcpsd = socket( AF_INET, SOCK_STREAM, 0 );
-	require_action( dnssd_SocketValid(self->tlssd), exit, err = mStatus_UnknownErr; LogErr( "SetupSockets", "socket" ) );
 	mDNSPlatformMemZero(&daddr, sizeof(daddr));
 	daddr.sin_family		= AF_INET;
 	daddr.sin_addr.s_addr	= zerov4Addr.NotAnInteger;
diff -Nru mDNSResponder-320.5/mDNSShared/dnsextd_parser.y mdns-patched/mDNSShared/dnsextd_parser.y
--- mDNSResponder-320.5/mDNSShared/dnsextd_parser.y	2010-03-17 20:26:12.000000000 +0000
+++ mdns-patched/mDNSShared/dnsextd_parser.y	2011-12-07 16:28:58.126854877 +0000
@@ -74,6 +74,7 @@
 	struct ZoneSpec	*	next;
 } ZoneSpec;
 
+int yydebug=0; // gck
 
 static StringListElem	*	g_stringList = NULL;
 static KeySpec			*	g_keys;
@@ -150,7 +151,7 @@
 options_set:
 		OPTIONS optionscontent
 		{
-			// SetupOptions( &g_optionsInfo, context );
+			//SetupOptions( &g_optionsInfo, context );
 		}
 		;
 
@@ -281,7 +282,7 @@
 		}
 		|
 		ALLOWUPDATE keycontent
-		{
+		{		
 			g_zoneSpec.allowUpdate = g_stringList;
 			g_stringList = NULL;
 		}
@@ -325,7 +326,7 @@
 		;
 
 keystatement:
-		KEY DOMAINNAME
+		KEY QUOTEDSTRING
 		{
 			StringListElem * elem;
 
